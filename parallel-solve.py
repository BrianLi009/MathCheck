import subprocess
import threading
import queue
import os

def run_command(command, q, order, directory, cube_initial, cube_next):
    # Run the command and check its output
    thread_id = threading.get_ident()

    # Log the command and thread ID
    print(f"Thread {thread_id}: Executing command: {command}")
    process = subprocess.Popen(command, stdout=subprocess.PIPE, stderr=subprocess.PIPE, shell=True)
    stdout, stderr = process.communicate()
    nextfile_pos = command.find("nextfile=")

    if nextfile_pos != -1:
        # Extract everything after 'nextfile='
        newfile = command[nextfile_pos + len("nextfile="):]
        if "UNSAT" not in stdout.decode():
            print("continue cubing this subproblem...")
            print(command)
            process_file(order, newfile, directory, cube_next, cube_next, newfile)
        else:
            remove_related_files(newfile)
    else:
        print("next cubing file not found")

def process_file(q, order, file_name_solve, directory, cube_initial, cube_next, file_name_cube):
    # Run the cube-solve-cc.sh script on the file with additional parameters
    subprocess.run(f"./cube-solve-cc.sh {order} {file_name_solve} {directory} {cube_initial} {cube_next} {file_name_cube}", shell=True)
    # Read the new file generated by cube-solve-cc.sh
    with open(f"{file_name_solve}.commands", "r") as file:
        for line in file:
            print(line)
            q.put((line.strip(), order, directory, cube_initial, cube_next))

def worker(q):
    while True:
        item = q.get()
        if item is None:
            q.task_done()
            break
        command, order, directory, cube_initial, cube_next = item
        run_command(command, q, order, directory, cube_initial, cube_next)
        q.task_done()

def remove_related_files(new_file):
    # Base part of the file name
    base_file = new_file.rsplit('.', 1)[0]

    # List of files to remove
    files_to_remove = [
        base_file,
        new_file,
        f"{new_file}.permcheck",
        f"{new_file}.nonembed",
        f"{new_file}.drat"
    ]

    # Removing the files
    for file in files_to_remove:
        try:
            os.remove(file)
            print(f"Removed: {file}")
        except OSError as e:
            print(f"Error: {e.strerror}. File: {file}")

def main(order, file_name_solve, directory, cube_initial, cube_next, file_name_cube):
    q = queue.Queue()
    num_worker_threads = 4  # Adjust based on CPU capacity

    threads = []
    for i in range(num_worker_threads):
        t = threading.Thread(target=worker, args=(q,))
        t.start()
        threads.append(t)

    process_file(q, order, file_name_solve, directory, cube_initial, cube_next, file_name_cube)

    # Block until all tasks are done
    q.join()

    # Stop workers
    for i in range(num_worker_threads):
        q.put(None)
    for t in threads:
        t.join()

if __name__ == "__main__":
    import sys
    if len(sys.argv) >= 7:
        main(sys.argv[1], sys.argv[2], sys.argv[3], sys.argv[4], sys.argv[5], sys.argv[6])
    else:
        print("Usage: python script.py <order> <file_name_solve> <directory> <cube_initial> <cube_next> <file_name_cube>")
