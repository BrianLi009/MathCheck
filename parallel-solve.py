import subprocess
import threading
import queue
import os

def run_command(command, q, param1, param2, param3, param4):
    # Run the command and check its output
    process = subprocess.Popen(command, stdout=subprocess.PIPE, stderr=subprocess.PIPE, shell=True)
    stdout, stderr = process.communicate()
    nextfile_pos = command.find("nextfile=")

    if nextfile_pos != -1:
        # Extract everything after 'nextfile='
        newfile = command[nextfile_pos + len("nextfile="):]
        if "UNSAT" not in stdout.decode():
            print("continue cubing this subproblem...")
            print(command)
            process_file(newfile, q, param1, param2, param3, param4)
        else:
            remove_related_files(newfile)
    else:
        print("next cubing file not found")

def process_file(file_name, q, param1, param2, param3, param4):
    # Run the cube-solve-cc.sh script on the file with additional parameters
    subprocess.run(f"./cube-solve-cc.sh {param1} {file_name} {param2} {param3} {param4}", shell=True)
    # Read the new file generated by cube-solve-cc.sh
    with open(f"{file_name}.commands", "r") as file:
        for line in file:
            print(line)
            q.put((line.strip(), param1, param2, param3, param4))

def worker(q):
    while True:
        item = q.get()
        if item is None:
            break
        command, param1, param2, param3, param4 = item
        run_command(command, q, param1, param2, param3, param4)
        q.task_done()

def remove_related_files(new_file):
    # Base part of the file name
    base_file = new_file.rsplit('.', 1)[0]

    # List of files to remove
    files_to_remove = [
        base_file,
        new_file,
        f"{new_file}.permcheck",
        f"{new_file}.nonembed",
        f"{new_file}.drat"
    ]

    # Removing the files
    for file in files_to_remove:
        try:
            os.remove(file)
            print(f"Removed: {file}")
        except OSError as e:
            print(f"Error: {e.strerror}. File: {file}")

def main(file_name, param1, param2, param3, param4):
    q = queue.Queue()
    num_worker_threads = 4  # Adjust based on CPU capacity

    threads = []
    for i in range(num_worker_threads):
        t = threading.Thread(target=worker, args=(q,))
        t.start()
        threads.append(t)

    process_file(file_name, q, param1, param2, param3, param4)

    # Block until all tasks are done
    q.join()

    # Stop workers
    for i in range(num_worker_threads):
        q.put(None)
    for t in threads:
        t.join()

if __name__ == "__main__":
    import sys
    if len(sys.argv) >= 6:
        main(sys.argv[1], sys.argv[2], sys.argv[3], sys.argv[4], sys.argv[5])
    else:
        print("Usage: python script.py <file_name> <param1> <param2> <param3> <param4>")
